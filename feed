#!/usr/bin/env bash

# === FEED.SH ===
# by Satoshi Soma (github.com/amekusa)

version="0.1.0"

_help() {
	cat << EOF
=== FEED.SH v$version ===
by Satoshi Soma (github.com/amekusa)

Usage:
  feed -f <file> -c <command>

Example:
  feed -f urls.txt -c wget {item}

Options:
  -h, --help     : Show this help.
  -f, --file     : Specify file(s) to iterate over.
                   Lines that start with '#' are ignored.
  -c, --cmd      : Specify a command to run.
                   Every occurrence of '{item}' in the command
                   gets replaced with each line in the file.
  -r, --replace  : Specify the placeholder to be replaced in
                   the command. (default: {item})
  -w, --write    : Specify a file to log items if the command failed.
  -i, --interval : Set iteration interval.
                   ex.) 5s = 5secs, 30m = 30mins, 1h = 1hour
  -p, --parallel : Run in parallel.

EOF
}

_err() {
	echo "[ERR] $1"
	exit 1
}

_main() {
	if [ -z "$1" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
		_help; return 1
	fi
	local ctx=''
	local err=false
	local file=()
	local cmd=''
	local replace='{item}'
	local write=''
	local interval=''
	local parallel=false
	while [ $# -gt 0 ]; do
		case "$ctx" in
		cmd) # cmd context
			cmd="$cmd $1"
			;;
		*)
			case "$1" in
			-f|--file)
				ctx=file
				;;
			-c|--cmd)
				ctx=cmd
				;;
			-r|--replace)
				ctx=replace
				;;
			-w|--write)
				ctx=write
				;;
			-i|--interval)
				ctx=interval
				;;
			-p|--parallel)
				parallel=true
				;;
			-*)
				err=true
				;;
			*)
				case "$ctx" in
				# contextual args
				file)
					file+=("$1")
					;;
				replace)
					replace="$1"
					ctx=''
					;;
				write)
					write="$1"
					ctx=''
					;;
				interval)
					interval="$1"
					ctx=''
					;;
				*)
					err=true
					;;
				esac
				;;
			esac
			;;
		esac
		$err && _err "invalid argument: '$1'"
		shift
	done

	[ -z "$cmd" ] && _err "specify command to run"
	cmd="${cmd:1}"

	local tmp
	if [ -n "$write" ]; then
		tmp="$(mktemp)" || _err "failed to create a temp file"
		cat <<- EOF > "$tmp"
		# Failed Items @ $(date +'%F %H:%M:%S')
		# command: $cmd

		EOF
	fi

	local sleep
	local f; for f in "${file[@]}"; do
		local IFS line
		while IFS= read -r line; do
			# skip blank lines and comment lines
			if [ -z "$line" ] || [[ "$line" =~ ^[[:space:]]*# ]]; then
				continue
			fi
			# run command
			[ -n "$sleep" ] && sleep "$sleep"
			local _cmd="${cmd//"$replace"/"$line"}" # replace '{item}' in $cmd with $line
			if $parallel; then
				_run "$_cmd" "$line" "$tmp" &
			else
				_run "$_cmd" "$line" "$tmp"
			fi
			# set interval
			sleep="$interval"
		done < "$f"
	done

	$parallel && wait

	cp "$tmp" "$write"
	rm "$tmp"
}

_run() {
	local out
	if out="$(eval "$1" 2>&1)"; then
		echo "$(date +'%H:%M:%S') [DONE] $1"
		return 0
	else
		local code="$?"
		echo "$(date +'%H:%M:%S') [FAIL] $1"
		if [ -n "$3" ]; then
			cat <<- EOF >> "$3"
			# $(date +'%F %H:%M:%S'), code:$code, err:$out
			$2

			EOF
		fi
		return 1
	fi
}

_main "$@"

